'use client';

import React, { useRef, useEffect, useState, useCallback } from 'react';
import { Point, Stroke, Character, Expression } from '@/lib/types';
import { calculateBoundingBox, generateId } from '@/lib/geometry';
import { addStrokeToCharacters } from '@/lib/stroke-grouping';
import { recognizeCharacter, initializeModel, isModelReady, isUsingMLModel } from '@/lib/recognizer';
import { buildExpressions, getResultPosition } from '@/lib/expression-parser';
import { Undo2, Redo2, Trash2, Bug, BugOff, Home, Palette, Keyboard } from 'lucide-react';
import Link from 'next/link';

const STROKE_COLORS = [
  { name: 'White', value: '#f0f0f0' },
  { name: 'Amber', value: '#f59e0b' },
  { name: 'Orange', value: '#f97316' },
  { name: 'Rose', value: '#f43f5e' },
  { name: 'Cyan', value: '#06b6d4' },
  { name: 'Lime', value: '#84cc16' },
];

export default function CanvasPage() {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const containerRef = useRef<HTMLDivElement>(null);
  const [canvasSize, setCanvasSize] = useState({ width: 800, height: 600 });
  
  const [isDrawing, setIsDrawing] = useState(false);
  const [currentStroke, setCurrentStroke] = useState<Point[]>([]);
  const [strokes, setStrokes] = useState<Stroke[]>([]);
  const [characters, setCharacters] = useState<Character[]>([]);
  const [expressions, setExpressions] = useState<Expression[]>([]);
  const [modelReady, setModelReady] = useState(false);
  const [usingML, setUsingML] = useState(false);
  const [isProcessing, setIsProcessing] = useState(false);
  
  const [debugMode, setDebugMode] = useState(false);
  const [strokeColor, setStrokeColor] = useState(STROKE_COLORS[0].value);
  const [showColorPicker, setShowColorPicker] = useState(false);
  const [showShortcuts, setShowShortcuts] = useState(false);
  const [undoStack, setUndoStack] = useState<{ strokes: Stroke[], characters: Character[] }[]>([]);
  const [redoStack, setRedoStack] = useState<{ strokes: Stroke[], characters: Character[] }[]>([]);

  const recognitionTimerRef = useRef<NodeJS.Timeout | null>(null);

  // Resize canvas to fill screen
  useEffect(() => {
    const updateSize = () => {
      if (containerRef.current) {
        const rect = containerRef.current.getBoundingClientRect();
        setCanvasSize({
          width: Math.floor(rect.width * window.devicePixelRatio),
          height: Math.floor(rect.height * window.devicePixelRatio),
        });
      }
    };

    updateSize();
    window.addEventListener('resize', updateSize);
    return () => window.removeEventListener('resize', updateSize);
  }, []);

  // Initialize model
  useEffect(() => {
    initializeModel().then(() => {
      setModelReady(true);
      setUsingML(isUsingMLModel());
    });
  }, []);

  // Undo handler
  const handleUndo = useCallback(() => {
    if (undoStack.length === 0) return;
    
    const lastState = undoStack[undoStack.length - 1];
    setRedoStack(prev => [...prev, { strokes, characters }]);
    setUndoStack(prev => prev.slice(0, -1));
    setStrokes(lastState.strokes);
    setCharacters(lastState.characters);
    setExpressions(buildExpressions(lastState.characters));
  }, [undoStack, strokes, characters]);

  // Redo handler
  const handleRedo = useCallback(() => {
    if (redoStack.length === 0) return;
    
    const nextState = redoStack[redoStack.length - 1];
    setUndoStack(prev => [...prev, { strokes, characters }]);
    setRedoStack(prev => prev.slice(0, -1));
    setStrokes(nextState.strokes);
    setCharacters(nextState.characters);
    setExpressions(buildExpressions(nextState.characters));
  }, [redoStack, strokes, characters]);

  // Clear handler
  const handleClear = useCallback(() => {
    if (strokes.length > 0) {
      setUndoStack(prev => [...prev, { strokes, characters }]);
      setRedoStack([]);
    }
    setStrokes([]);
    setCharacters([]);
    setExpressions([]);
    setCurrentStroke([]);
  }, [strokes, characters]);

  // Keyboard shortcuts
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
        e.preventDefault();
        handleUndo();
      }
      if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {
        e.preventDefault();
        handleRedo();
      }
      if ((e.ctrlKey || e.metaKey) && (e.key === 'Delete' || e.key === 'Backspace')) {
        e.preventDefault();
        handleClear();
      }
      if (e.key === 'd' && !e.ctrlKey && !e.metaKey && document.activeElement?.tagName !== 'INPUT') {
        setDebugMode(prev => !prev);
      }
      if (e.key === 'Escape') {
        setShowColorPicker(false);
        setShowShortcuts(false);
      }
      if (e.key === '?') {
        setShowShortcuts(prev => !prev);
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [handleUndo, handleRedo, handleClear]);

  // Redraw canvas
  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    const dpr = window.devicePixelRatio;

    // Create dramatic gradient background
    const bgGradient = ctx.createRadialGradient(
      canvas.width * 0.2, canvas.height * 0.3, 0,
      canvas.width * 0.5, canvas.height * 0.5, canvas.width * 0.8
    );
    bgGradient.addColorStop(0, '#0c0c0f');
    bgGradient.addColorStop(0.5, '#080809');
    bgGradient.addColorStop(1, '#050506');
    ctx.fillStyle = bgGradient;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Add ambient glow spots
    const drawGlow = (x: number, y: number, radius: number, color1: string, color2: string) => {
      const glow = ctx.createRadialGradient(x, y, 0, x, y, radius);
      glow.addColorStop(0, color1);
      glow.addColorStop(0.5, color2);
      glow.addColorStop(1, 'transparent');
      ctx.fillStyle = glow;
      ctx.fillRect(x - radius, y - radius, radius * 2, radius * 2);
    };

    drawGlow(canvas.width * 0.15, canvas.height * 0.2, canvas.width * 0.3, 'rgba(59, 130, 246, 0.08)', 'rgba(37, 99, 235, 0.03)');
    drawGlow(canvas.width * 0.85, canvas.height * 0.25, canvas.width * 0.35, 'rgba(249, 115, 22, 0.1)', 'rgba(234, 88, 12, 0.04)');
    drawGlow(canvas.width * 0.7, canvas.height * 0.7, canvas.width * 0.4, 'rgba(168, 85, 247, 0.06)', 'rgba(139, 92, 246, 0.02)');
    drawGlow(canvas.width * 0.2, canvas.height * 0.8, canvas.width * 0.25, 'rgba(236, 72, 153, 0.07)', 'rgba(219, 39, 119, 0.03)');

    // Draw subtle grid
    ctx.fillStyle = 'rgba(255, 255, 255, 0.015)';
    const gridSize = 28 * dpr;
    for (let x = gridSize; x < canvas.width; x += gridSize) {
      for (let y = gridSize; y < canvas.height; y += gridSize) {
        ctx.beginPath();
        ctx.arc(x, y, 0.5 * dpr, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    // Draw strokes
    ctx.lineWidth = 2.5 * dpr;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';

    for (const stroke of strokes) {
      if (stroke.points.length < 2) continue;
      
      ctx.strokeStyle = strokeColor;
      ctx.shadowColor = strokeColor;
      ctx.shadowBlur = 8 * dpr;
      
      ctx.beginPath();
      ctx.moveTo(stroke.points[0].x, stroke.points[0].y);
      for (let i = 1; i < stroke.points.length; i++) {
        ctx.lineTo(stroke.points[i].x, stroke.points[i].y);
      }
      ctx.stroke();
      ctx.shadowBlur = 0;
    }

    // Draw current stroke
    if (currentStroke.length > 1) {
      ctx.strokeStyle = '#f59e0b';
      ctx.shadowColor = '#f59e0b';
      ctx.shadowBlur = 12 * dpr;
      
      ctx.beginPath();
      ctx.moveTo(currentStroke[0].x, currentStroke[0].y);
      for (let i = 1; i < currentStroke.length; i++) {
        ctx.lineTo(currentStroke[i].x, currentStroke[i].y);
      }
      ctx.stroke();
      ctx.shadowBlur = 0;
    }

    // Debug mode: Draw bounding boxes
    if (debugMode) {
      for (const char of characters) {
        const bb = char.boundingBox;
        
        ctx.strokeStyle = char.recognized 
          ? 'rgba(34, 197, 94, 0.5)' 
          : 'rgba(251, 191, 36, 0.5)';
        ctx.lineWidth = 1 * dpr;
        ctx.setLineDash([4 * dpr, 4 * dpr]);
        ctx.strokeRect(bb.minX - 4, bb.minY - 4, bb.width + 8, bb.height + 8);
        ctx.setLineDash([]);
        
        if (char.recognized) {
          ctx.font = `600 ${12 * dpr}px ui-monospace, monospace`;
          ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
          const labelText = `${char.recognized} ${Math.round(char.confidence * 100)}%`;
          const textWidth = ctx.measureText(labelText).width;
          ctx.fillRect(bb.minX - 2, bb.minY - 20 * dpr, textWidth + 8, 16 * dpr);
          
          ctx.fillStyle = '#22c55e';
          ctx.fillText(labelText, bb.minX + 2, bb.minY - 6 * dpr);
        }
      }
    }

    // Draw results with amber glow
    ctx.font = `600 ${52 * dpr}px Caveat, cursive`;
    for (const expr of expressions) {
      if (expr.result) {
        const pos = getResultPosition(expr);
        if (pos) {
          ctx.shadowColor = 'rgba(249, 115, 22, 0.6)';
          ctx.shadowBlur = 16 * dpr;
          ctx.fillStyle = '#fb923c';
          ctx.fillText(expr.result, pos.x, pos.y + 18 * dpr);
          ctx.shadowBlur = 0;
        }
      }
    }

  }, [strokes, currentStroke, characters, expressions, debugMode, strokeColor, canvasSize]);

  // Process stroke
  const processStroke = useCallback(async (newStroke: Stroke) => {
    setCharacters(prev => addStrokeToCharacters(prev, newStroke));
  }, []);

  // Recognition
  const scheduleRecognition = useCallback(() => {
    if (recognitionTimerRef.current) {
      clearTimeout(recognitionTimerRef.current);
    }

    recognitionTimerRef.current = setTimeout(async () => {
      if (!isModelReady()) return;
      
      setIsProcessing(true);
      
      setCharacters(prev => {
        const needsRecognition = prev.filter(c => c.recognized === null);
        if (needsRecognition.length === 0) {
          setIsProcessing(false);
          return prev;
        }

        Promise.all(
          needsRecognition.map(async char => {
            const result = await recognizeCharacter(char);
            return { ...char, recognized: result.label, confidence: result.confidence };
          })
        ).then(recognizedChars => {
          setCharacters(current => {
            const recognized = new Map(recognizedChars.map(c => [c.id, c]));
            const updated = current.map(c => recognized.get(c.id) || c);
            setExpressions(buildExpressions(updated));
            return updated;
          });
          setIsProcessing(false);
        });

        return prev;
      });
    }, 250);
  }, []);

  // Get canvas point
  const getCanvasPoint = useCallback((clientX: number, clientY: number): Point => {
    const canvas = canvasRef.current;
    if (!canvas) return { x: 0, y: 0, timestamp: Date.now() };

    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;

    return {
      x: (clientX - rect.left) * scaleX,
      y: (clientY - rect.top) * scaleY,
      timestamp: Date.now(),
    };
  }, []);

  // Pointer handlers
  const handlePointerDown = useCallback((e: React.PointerEvent<HTMLCanvasElement>) => {
    e.preventDefault();
    setIsDrawing(true);
    const point = getCanvasPoint(e.clientX, e.clientY);
    setCurrentStroke([point]);
  }, [getCanvasPoint]);

  const handlePointerMove = useCallback((e: React.PointerEvent<HTMLCanvasElement>) => {
    if (!isDrawing) return;
    e.preventDefault();
    const point = getCanvasPoint(e.clientX, e.clientY);
    setCurrentStroke(prev => [...prev, point]);
  }, [isDrawing, getCanvasPoint]);

  const handlePointerUp = useCallback(() => {
    if (!isDrawing || currentStroke.length < 2) {
      setIsDrawing(false);
      setCurrentStroke([]);
      return;
    }

    setUndoStack(prev => [...prev, { strokes, characters }]);
    setRedoStack([]);

    const newStroke: Stroke = {
      id: generateId(),
      points: currentStroke,
      boundingBox: calculateBoundingBox(currentStroke),
    };

    setStrokes(prev => [...prev, newStroke]);
    setIsDrawing(false);
    setCurrentStroke([]);

    processStroke(newStroke);
    scheduleRecognition();
  }, [isDrawing, currentStroke, strokes, characters, processStroke, scheduleRecognition]);

  return (
    <div className="h-[100dvh] w-full bg-[#050506] flex flex-col overflow-hidden touch-none">
      {/* Top toolbar */}
      <div className="flex items-center justify-between px-3 py-2 bg-black/60 backdrop-blur-md border-b border-white/[0.04] z-10">
        <div className="flex items-center gap-1">
          <Link href="/">
            <button className="p-2 rounded-lg hover:bg-white/5 text-gray-500 hover:text-white transition-colors">
              <Home className="w-5 h-5" />
            </button>
          </Link>
          <div className="w-px h-6 bg-white/[0.06] mx-1" />
          <button
            onClick={handleUndo}
            disabled={undoStack.length === 0}
            className="p-2 rounded-lg hover:bg-white/5 text-gray-500 hover:text-white transition-colors disabled:opacity-30 disabled:cursor-not-allowed"
            title="Undo (Ctrl+Z)"
          >
            <Undo2 className="w-5 h-5" />
          </button>
          <button
            onClick={handleRedo}
            disabled={redoStack.length === 0}
            className="p-2 rounded-lg hover:bg-white/5 text-gray-500 hover:text-white transition-colors disabled:opacity-30 disabled:cursor-not-allowed"
            title="Redo (Ctrl+Y)"
          >
            <Redo2 className="w-5 h-5" />
          </button>
        </div>

        {/* Status badges */}
        <div className="flex items-center gap-2">
          {!modelReady && (
            <span className="bg-amber-500/20 text-amber-400 px-2 py-1 rounded-md text-[10px] font-medium uppercase tracking-wider animate-pulse">
              Loading...
            </span>
          )}
          {modelReady && usingML && (
            <span className="bg-emerald-500/10 text-emerald-400 px-2 py-1 rounded-md text-[10px] font-medium uppercase tracking-wider flex items-center gap-1">
              <span className="w-1 h-1 rounded-full bg-emerald-400" />
              ML
            </span>
          )}
          {isProcessing && (
            <span className="bg-amber-500/10 text-amber-400 px-2 py-1 rounded-md text-[10px] font-medium uppercase tracking-wider animate-pulse">
              ...
            </span>
          )}
        </div>

        <div className="flex items-center gap-1">
          <button
            onClick={() => setShowShortcuts(!showShortcuts)}
            className={`p-2 rounded-lg hover:bg-white/5 transition-colors ${showShortcuts ? 'text-amber-400' : 'text-gray-500 hover:text-white'}`}
            title="Keyboard shortcuts (?)"
          >
            <Keyboard className="w-5 h-5" />
          </button>
          <div className="relative">
            <button
              onClick={() => setShowColorPicker(!showColorPicker)}
              className="p-2 rounded-lg hover:bg-white/5 transition-colors"
              title="Stroke color"
            >
              <Palette className="w-5 h-5" style={{ color: strokeColor }} />
            </button>
            {showColorPicker && (
              <div className="absolute top-full right-0 mt-2 p-2 bg-[#0c0c0f] rounded-lg border border-white/[0.08] flex gap-1.5 z-20 shadow-2xl">
                {STROKE_COLORS.map(color => (
                  <button
                    key={color.value}
                    onClick={() => {
                      setStrokeColor(color.value);
                      setShowColorPicker(false);
                    }}
                    className={`w-7 h-7 rounded-full border-2 transition-all hover:scale-110 ${
                      strokeColor === color.value ? 'border-white scale-110 shadow-lg' : 'border-transparent'
                    }`}
                    style={{ backgroundColor: color.value, boxShadow: strokeColor === color.value ? `0 0 12px ${color.value}` : 'none' }}
                  />
                ))}
              </div>
            )}
          </div>
          <button
            onClick={() => setDebugMode(!debugMode)}
            className={`p-2 rounded-lg hover:bg-white/5 transition-colors ${debugMode ? 'text-emerald-400' : 'text-gray-500 hover:text-white'}`}
            title="Debug mode (D)"
          >
            {debugMode ? <Bug className="w-5 h-5" /> : <BugOff className="w-5 h-5" />}
          </button>
          <button
            onClick={handleClear}
            className="p-2 rounded-lg hover:bg-red-500/10 text-gray-500 hover:text-red-400 transition-colors"
            title="Clear (Ctrl+Delete)"
          >
            <Trash2 className="w-5 h-5" />
          </button>
        </div>
      </div>

      {/* Shortcuts modal */}
      {showShortcuts && (
        <div className="absolute top-14 right-3 z-30 bg-[#0c0c0f]/95 backdrop-blur-md rounded-lg border border-white/[0.08] p-4 shadow-2xl">
          <h3 className="text-xs font-semibold text-white mb-3 uppercase tracking-wider">Keyboard Shortcuts</h3>
          <div className="space-y-2 text-xs">
            <div className="flex justify-between gap-6">
              <span className="text-gray-500">Undo</span>
              <kbd className="px-1.5 py-0.5 bg-white/5 rounded text-gray-400 font-mono">Ctrl+Z</kbd>
            </div>
            <div className="flex justify-between gap-6">
              <span className="text-gray-500">Redo</span>
              <kbd className="px-1.5 py-0.5 bg-white/5 rounded text-gray-400 font-mono">Ctrl+Y</kbd>
            </div>
            <div className="flex justify-between gap-6">
              <span className="text-gray-500">Clear</span>
              <kbd className="px-1.5 py-0.5 bg-white/5 rounded text-gray-400 font-mono">Ctrl+Del</kbd>
            </div>
            <div className="flex justify-between gap-6">
              <span className="text-gray-500">Debug</span>
              <kbd className="px-1.5 py-0.5 bg-white/5 rounded text-gray-400 font-mono">D</kbd>
            </div>
            <div className="flex justify-between gap-6">
              <span className="text-gray-500">Close</span>
              <kbd className="px-1.5 py-0.5 bg-white/5 rounded text-gray-400 font-mono">Esc</kbd>
            </div>
          </div>
        </div>
      )}

      {/* Canvas area */}
      <div ref={containerRef} className="flex-1 relative">
        <canvas
          ref={canvasRef}
          width={canvasSize.width}
          height={canvasSize.height}
          className="absolute inset-0 w-full h-full cursor-crosshair"
          onPointerDown={handlePointerDown}
          onPointerMove={handlePointerMove}
          onPointerUp={handlePointerUp}
          onPointerLeave={handlePointerUp}
          onPointerCancel={handlePointerUp}
          style={{ touchAction: 'none' }}
        />
        
        {strokes.length === 0 && (
          <div className="absolute inset-0 flex items-center justify-center pointer-events-none">
            <div className="text-center text-gray-600">
              <p className="text-base font-medium tracking-wide">Draw anywhere</p>
              <p className="text-sm text-gray-700 mt-1 font-mono">Try: 12+8=</p>
            </div>
          </div>
        )}
      </div>

      {/* Bottom bar */}
      {expressions.length > 0 && (
        <div className="px-3 py-2 bg-black/60 backdrop-blur-md border-t border-white/[0.04]">
          <div className="flex flex-wrap gap-2 justify-center">
            {expressions.map(expr => (
              <span key={expr.id} className="px-3 py-1.5 bg-white/[0.03] rounded-lg text-sm border border-white/[0.04] font-mono">
                <span className="text-gray-400">{expr.text}</span>
                {expr.result && <span className="text-amber-400 font-semibold"> {expr.result}</span>}
              </span>
            ))}
          </div>
        </div>
      )}
    </div>
  );
}
